/*
 * generated by Xtext
 */
package org.xtext.generator

import com.google.inject.Inject
import java.io.BufferedWriter
import java.io.File
import java.io.FileWriter
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.resource.XtextResourceSet
import org.xtext.Langage_whileStandaloneSetup
import org.xtext.langage_while.Command
import org.xtext.langage_while.Commands
import org.xtext.langage_while.Def
import org.xtext.langage_while.EXPR
import org.xtext.langage_while.EXPRAND
import org.xtext.langage_while.EXPREQ
import org.xtext.langage_while.EXPRNOT
import org.xtext.langage_while.EXPROR
import org.xtext.langage_while.EXPRS
import org.xtext.langage_while.EXPRSIMPLE
import org.xtext.langage_while.Function
import org.xtext.langage_while.Input
import org.xtext.langage_while.LC
import org.xtext.langage_while.LCs
import org.xtext.langage_while.LEXPR
import org.xtext.langage_while.Model
import org.xtext.langage_while.Output
import org.xtext.langage_while.Program
import org.xtext.langage_while.Vars
import tabSymb.*
import org.xtext.langage_while.If
import org.xtext.langage_while.Assign
import org.xtext.langage_while.For
import org.xtext.langage_while.Foreach
import org.xtext.langage_while.While

class Langage_whileGenerator implements IGenerator {
	
	
	def public File generate(String path, String file)
	{
		val injector = new Langage_whileStandaloneSetup().createInjectorAndDoEMFRegistration();
		val resourceSet = injector.getInstance(XtextResourceSet);
		val uri = URI.createURI(path + file);
		
		var pos = file.lastIndexOf(".");
		var ext = file.substring(pos+1);
		//TODO
		if (! ext.equals("while"))
			return null;
			
		val xtextResource = resourceSet.getResource(uri, true);
		EcoreUtil.resolveAll(xtextResource);
		var name = file.substring(0, pos);
		var out = name;
		if (path.equals("src/outputs/"))
			out += "1";
		out += ".whpp";
			
		try{
			
  			val fstream = new FileWriter("src/outputs/" + out);
  			val buff = new BufferedWriter(fstream);
  			for(p: xtextResource.allContents.toIterable.filter(Program))
				buff.write(p.compile().toString);
  			buff.close();
  			return new File("src/outputs/" + out);
  		}catch (Exception e){
  			e.printStackTrace();
  		}
  		return null;
	}
	
	def Fonction createFonct(int i){
		return  new Fonction("funct"+i);
	}
	
	  @Inject extension IQualifiedNameProvider
	
		TabSymbole tableS= new TabSymbole();
		Fonction fonct;
		int cpt=0;
	
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
    for(e: resource.allContents.toIterable.filter(typeof(Model))) {
      fsa.generateFile(
        //e.toString+
        "test.whpp",
        e.compile)
    }
  }
		
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(typeof(Greeting))
//				.map[name]
//				.join(', '))
	
	
	def compile (Model l)
	'''
	«l.greetings.compile»
	«tableS.afficher()»
	'''
	
	
	
	def compile (Program p)
	'''
	«cpt=0»
	«FOR f:p.f»
	«f.compile»
	«ENDFOR» 
	«((p.u)+(p)) ?: ("")»
	'''
	
	def compile (Function f)
	'''	«tableS.addSymbole(f.nom)»
	« cpt++»
	« fonct = createFonct(cpt) »
	«tableS.addFonction(f.nom,fonct)»
		
		«"function " +f.nom + ":" + "
" + f.d.compile(f.nom)
		»
	'''
	
	def compile (Def d, String a)
	'''
		
		read «d.in.compile(a)+"
	"» % «d.v.compile+"
	"» % write  «d.o.compile(a)»
	'''
	
	def compile (Input l, String a)
	'''«fonct.incNbEntree()»
	«if (l.y!=null)
	fonct.addVariable(l.y)
	else
	fonct.addVariable(l.v)»
	«(l.y)  ?: ((l.v)+" , "+(l.in.compile(a)))» 
		'''
	
	
	def compile (Commands n)
	'''
	«n.a.compile»
	«IF n.s != null»
	«n.s.compile»
	«ENDIF»
	''' 
	
	def compile (Output O, String a)
	'''
	«fonct.incNbSortie()»
	«if (O.s!=null)
	""
	else
	
	(O.s) ?:  ((O.n)+", "+(O.o.compile(a)))»
	'''
	
	def compile (Command c)  // a continuer
	'''
	«IF c.affect != null»«c.affect.compile»«ENDIF»
	«IF c.nop != null»nop«ENDIF»
	«IF c.iff != null»«c.iff.compile»«ENDIF»
	«IF c.wh != null»«c.wh.compile»«ENDIF»
	«IF c.forr != null»«c.forr.compile»«ENDIF»
	«IF c.fore != null»«c.fore.compile»«ENDIF»
	'''
	
	
	def compile(Assign a)
	 '''
	 «a.e.compile» := «a.n.compile»
	 '''
	def compile(If i) 
	'''
	if «i.jj.compile»
	then
	«i.c2.compile»
	else
	«i.o.compile»
	fi
	'''

	def compile(For f)
	 '''
	 for «f.hh.compile»
	 do
		«f.c1.compile»
	 od
	'''

	def compile(Foreach f) 
	'''
	foreach «f.wx.compile» in «f.e1.compile»
	do
	«f.c3.compile»
	od'''

	def compile(While w) 
	'''
	while «w.ee.compile»
	do
	«w.k.compile»
	od
	'''
	
	def compile (Vars v)
	'''
	«(v.a) + ((", "+(v)) ?: (""))»
	'''
	
	def compile (EXPRS e)
	'''
	« e.f.compile + ( (", " + e.e2.compile) ?: ("") )
	»
	'''
	
	
	
	def compile (LEXPR l)
	'''
	«("/t"+(l.n.compile)) ?:(l)»
	'''	
	
	def compile (EXPR e)
	'''nil
	«
	switch (e)
	{
	case e.e1!=null : e.e1.compile

	case e.ex!=null : e.ex.compile
}
»
	'''
	
	def compile (EXPRSIMPLE ex) // a revoir
	'''
	
	«"nil" 
	?:( (ex.l) 
		
		?: ((ex.s)
			 
			?: ( ( "( cons" + ex.yy.compile + ")" )
				
				?: ( ("( hd " + ex.g.compile + ")")
					
					?: ( ("( list " + ex.b.compile)
						
						?: ( ("( tl " + ex.g.compile + ")")
							
							?: ("(" + ex.v + ex.w.compile + ")"
								
								
							)
							
						)
						
					) 
					
				)
						
			)
			
		) 
		
	)»
	«if (ex.v.length != 0)
	tableS.addSymbole(ex.v)»
	

	
	
	'''
	
	def compile (EXPRAND e)
	'''
	«(e.f.compile) + (( " and " + e.lc2.compile + e) ?: (""))
	»
	'''
	
	def compile (EXPROR e)
	'''
	«(e.e1.compile) + (( e.lc1.compile + " or " + e) ?: (""))
	»
	'''
	def compile (EXPRNOT e)
	'''
	« (("not ") ?: ("")) + e.e1.compile
	»
	'''
	
	def compile (EXPREQ f)
	'''
	« (f.e1.compile +  " =? " + f.w.compile) ?: ("(" + f.ex.compile + ")")
	»
	'''
	
	def compile (LCs l)
	'''
	«(l.a.compile) ?: ("")
	»
	'''
	
	def compile (LC m)
	'''
	« (m.a)
	?:( (m.z) 
		?:( (m.e)
			?: (m.r)
			
		)
		
	)
	»
	'''
	
	
	
	
}

