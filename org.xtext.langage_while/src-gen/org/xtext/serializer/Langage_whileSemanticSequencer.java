/*
 * generated by Xtext
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.langage_while.Assign;
import org.xtext.langage_while.Command;
import org.xtext.langage_while.Commands;
import org.xtext.langage_while.Def;
import org.xtext.langage_while.EXPR;
import org.xtext.langage_while.EXPRAND;
import org.xtext.langage_while.EXPREQ;
import org.xtext.langage_while.EXPRNOT;
import org.xtext.langage_while.EXPROR;
import org.xtext.langage_while.EXPRS;
import org.xtext.langage_while.EXPRSIMPLE;
import org.xtext.langage_while.For;
import org.xtext.langage_while.Foreach;
import org.xtext.langage_while.Function;
import org.xtext.langage_while.If;
import org.xtext.langage_while.Input;
import org.xtext.langage_while.LC;
import org.xtext.langage_while.LCs;
import org.xtext.langage_while.LEXPR;
import org.xtext.langage_while.Langage_whilePackage;
import org.xtext.langage_while.Model;
import org.xtext.langage_while.Output;
import org.xtext.langage_while.Variable;
import org.xtext.langage_while.Vars;
import org.xtext.langage_while.While;
import org.xtext.services.Langage_whileGrammarAccess;

@SuppressWarnings("all")
public class Langage_whileSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private Langage_whileGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == Langage_whilePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case Langage_whilePackage.ASSIGN:
				sequence_Assign(context, (Assign) semanticObject); 
				return; 
			case Langage_whilePackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case Langage_whilePackage.COMMANDS:
				sequence_Commands(context, (Commands) semanticObject); 
				return; 
			case Langage_whilePackage.DEF:
				sequence_Def(context, (Def) semanticObject); 
				return; 
			case Langage_whilePackage.EXPR:
				sequence_EXPR(context, (EXPR) semanticObject); 
				return; 
			case Langage_whilePackage.EXPRAND:
				sequence_EXPRAND(context, (EXPRAND) semanticObject); 
				return; 
			case Langage_whilePackage.EXPREQ:
				sequence_EXPREQ(context, (EXPREQ) semanticObject); 
				return; 
			case Langage_whilePackage.EXPRNOT:
				sequence_EXPRNOT(context, (EXPRNOT) semanticObject); 
				return; 
			case Langage_whilePackage.EXPROR:
				sequence_EXPROR(context, (EXPROR) semanticObject); 
				return; 
			case Langage_whilePackage.EXPRS:
				sequence_EXPRS(context, (EXPRS) semanticObject); 
				return; 
			case Langage_whilePackage.EXPRSIMPLE:
				sequence_EXPRSIMPLE(context, (EXPRSIMPLE) semanticObject); 
				return; 
			case Langage_whilePackage.FOR:
				sequence_For(context, (For) semanticObject); 
				return; 
			case Langage_whilePackage.FOREACH:
				sequence_Foreach(context, (Foreach) semanticObject); 
				return; 
			case Langage_whilePackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case Langage_whilePackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case Langage_whilePackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case Langage_whilePackage.LC:
				sequence_LC(context, (LC) semanticObject); 
				return; 
			case Langage_whilePackage.LCS:
				sequence_LCs(context, (LCs) semanticObject); 
				return; 
			case Langage_whilePackage.LEXPR:
				sequence_LEXPR(context, (LEXPR) semanticObject); 
				return; 
			case Langage_whilePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case Langage_whilePackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case Langage_whilePackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case Langage_whilePackage.VARS:
				sequence_Vars(context, (Vars) semanticObject); 
				return; 
			case Langage_whilePackage.WHILE:
				sequence_While(context, (While) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (e=Vars l=LCs c=LCs n=EXPRS)
	 */
	protected void sequence_Assign(EObject context, Assign semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.ASSIGN__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.ASSIGN__E));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.ASSIGN__L) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.ASSIGN__L));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.ASSIGN__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.ASSIGN__C));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.ASSIGN__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.ASSIGN__N));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssignAccess().getEVarsParserRuleCall_0_0(), semanticObject.getE());
		feeder.accept(grammarAccess.getAssignAccess().getLLCsParserRuleCall_1_0(), semanticObject.getL());
		feeder.accept(grammarAccess.getAssignAccess().getCLCsParserRuleCall_3_0(), semanticObject.getC());
		feeder.accept(grammarAccess.getAssignAccess().getNEXPRSParserRuleCall_4_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         nop=Nop | 
	 *         affect=Assign | 
	 *         wh=While | 
	 *         forr=For | 
	 *         fore=Foreach | 
	 *         iff=If
	 *     )
	 */
	protected void sequence_Command(EObject context, Command semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (a=Command (l=LCs s=Commands)?)
	 */
	protected void sequence_Commands(EObject context, Commands semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         l=LCs 
	 *         in=Input 
	 *         z=LCs 
	 *         v=Commands 
	 *         s=LCs 
	 *         u=LCs 
	 *         o=Output
	 *     )
	 */
	protected void sequence_Def(EObject context, Def semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.DEF__L) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.DEF__L));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.DEF__IN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.DEF__IN));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.DEF__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.DEF__Z));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.DEF__V) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.DEF__V));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.DEF__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.DEF__S));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.DEF__U) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.DEF__U));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.DEF__O) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.DEF__O));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDefAccess().getLLCsParserRuleCall_1_0(), semanticObject.getL());
		feeder.accept(grammarAccess.getDefAccess().getInInputParserRuleCall_2_0(), semanticObject.getIn());
		feeder.accept(grammarAccess.getDefAccess().getZLCsParserRuleCall_3_0(), semanticObject.getZ());
		feeder.accept(grammarAccess.getDefAccess().getVCommandsParserRuleCall_5_0(), semanticObject.getV());
		feeder.accept(grammarAccess.getDefAccess().getSLCsParserRuleCall_6_0(), semanticObject.getS());
		feeder.accept(grammarAccess.getDefAccess().getULCsParserRuleCall_9_0(), semanticObject.getU());
		feeder.accept(grammarAccess.getDefAccess().getOOutputParserRuleCall_10_0(), semanticObject.getO());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (f=EXPROR (lc1=LCs lc2=LCs ee=EXPRAND)?)
	 */
	protected void sequence_EXPRAND(EObject context, EXPRAND semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((e1=EXPRSIMPLE ccc=LCs lc2=LCs w=EXPRSIMPLE) | ex=EXPR)
	 */
	protected void sequence_EXPREQ(EObject context, EXPREQ semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (lc1=LCs? e1=EXPREQ)
	 */
	protected void sequence_EXPRNOT(EObject context, EXPRNOT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (e1=EXPRNOT (lc1=LCs lc2=LCs e2=EXPROR)?)
	 */
	protected void sequence_EXPROR(EObject context, EXPROR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         nil='nil' | 
	 *         v=VAR | 
	 *         sym=SYM | 
	 *         ((mot='cons' | mot='list') lex=LEXPR) | 
	 *         ((mot='hd' | mot='tl') l=LCs ex=EXPR) | 
	 *         (sym=SYM lex=LEXPR)
	 *     )
	 */
	protected void sequence_EXPRSIMPLE(EObject context, EXPRSIMPLE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (f=EXPR (l=LCs e2=EXPRS)?)
	 */
	protected void sequence_EXPRS(EObject context, EXPRS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (e1=EXPRSIMPLE | ex=EXPRAND)
	 */
	protected void sequence_EXPR(EObject context, EXPR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         cc=LCs 
	 *         hh=EXPR 
	 *         tt=LCs 
	 *         vv=LCs 
	 *         c1=Commands 
	 *         ss=LCs
	 *     )
	 */
	protected void sequence_For(EObject context, For semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOR__CC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOR__CC));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOR__HH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOR__HH));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOR__TT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOR__TT));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOR__VV) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOR__VV));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOR__C1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOR__C1));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOR__SS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOR__SS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getForAccess().getCcLCsParserRuleCall_1_0(), semanticObject.getCc());
		feeder.accept(grammarAccess.getForAccess().getHhEXPRParserRuleCall_2_0(), semanticObject.getHh());
		feeder.accept(grammarAccess.getForAccess().getTtLCsParserRuleCall_3_0(), semanticObject.getTt());
		feeder.accept(grammarAccess.getForAccess().getVvLCsParserRuleCall_5_0(), semanticObject.getVv());
		feeder.accept(grammarAccess.getForAccess().getC1CommandsParserRuleCall_6_0(), semanticObject.getC1());
		feeder.accept(grammarAccess.getForAccess().getSsLCsParserRuleCall_7_0(), semanticObject.getSs());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         sq=LCs 
	 *         wx=EXPR 
	 *         lc=LCs 
	 *         lc2=LCs 
	 *         e1=EXPR 
	 *         lc3=LCs 
	 *         lc4=LCs 
	 *         c3=Commands 
	 *         lc5=LCs
	 *     )
	 */
	protected void sequence_Foreach(EObject context, Foreach semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOREACH__SQ) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOREACH__SQ));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOREACH__WX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOREACH__WX));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOREACH__LC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOREACH__LC));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOREACH__LC2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOREACH__LC2));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOREACH__E1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOREACH__E1));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOREACH__LC3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOREACH__LC3));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOREACH__LC4) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOREACH__LC4));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOREACH__C3) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOREACH__C3));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOREACH__LC5) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOREACH__LC5));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getForeachAccess().getSqLCsParserRuleCall_1_0(), semanticObject.getSq());
		feeder.accept(grammarAccess.getForeachAccess().getWxEXPRParserRuleCall_2_0(), semanticObject.getWx());
		feeder.accept(grammarAccess.getForeachAccess().getLcLCsParserRuleCall_3_0(), semanticObject.getLc());
		feeder.accept(grammarAccess.getForeachAccess().getLc2LCsParserRuleCall_5_0(), semanticObject.getLc2());
		feeder.accept(grammarAccess.getForeachAccess().getE1EXPRParserRuleCall_6_0(), semanticObject.getE1());
		feeder.accept(grammarAccess.getForeachAccess().getLc3LCsParserRuleCall_7_0(), semanticObject.getLc3());
		feeder.accept(grammarAccess.getForeachAccess().getLc4LCsParserRuleCall_9_0(), semanticObject.getLc4());
		feeder.accept(grammarAccess.getForeachAccess().getC3CommandsParserRuleCall_10_0(), semanticObject.getC3());
		feeder.accept(grammarAccess.getForeachAccess().getLc5LCsParserRuleCall_11_0(), semanticObject.getLc5());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (n=LCs nom=SYM t=LCs d=Def)
	 */
	protected void sequence_Function(EObject context, Function semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FUNCTION__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FUNCTION__N));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FUNCTION__NOM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FUNCTION__NOM));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FUNCTION__T) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FUNCTION__T));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FUNCTION__D) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FUNCTION__D));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFunctionAccess().getNLCsParserRuleCall_1_0(), semanticObject.getN());
		feeder.accept(grammarAccess.getFunctionAccess().getNomSYMTerminalRuleCall_2_0(), semanticObject.getNom());
		feeder.accept(grammarAccess.getFunctionAccess().getTLCsParserRuleCall_4_0(), semanticObject.getT());
		feeder.accept(grammarAccess.getFunctionAccess().getDDefParserRuleCall_5_0(), semanticObject.getD());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         mm=LCs 
	 *         jj=EXPR 
	 *         kk=LCs 
	 *         hg=LCs 
	 *         c2=Commands 
	 *         gg=LCs 
	 *         (ff=LCs o=Commands dd=LCs)?
	 *     )
	 */
	protected void sequence_If(EObject context, If semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((v=VAR z=LCs in=Input) | y=VAR)
	 */
	protected void sequence_Input(EObject context, Input semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (a=SP | z=CR | e=TAB | r=LF)
	 */
	protected void sequence_LC(EObject context, LC semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     l=LC?
	 */
	protected void sequence_LCs(EObject context, LCs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (f=LCs n=EXPR t=LEXPR?)
	 */
	protected void sequence_LEXPR(EObject context, LEXPR semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     prog+=Function*
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((n=VAR q=LCs o=Output) | s=VAR)
	 */
	protected void sequence_Output(EObject context, Output semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     n=VAR
	 */
	protected void sequence_Variable(EObject context, Variable semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.VARIABLE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.VARIABLE__N));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVariableAccess().getNVARTerminalRuleCall_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (a=VAR (l=LCs u=Vars)?)
	 */
	protected void sequence_Vars(EObject context, Vars semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         ll=LCs 
	 *         ee=EXPR 
	 *         cc=LCs 
	 *         z=LCs 
	 *         k=Commands 
	 *         lc=LCs
	 *     )
	 */
	protected void sequence_While(EObject context, While semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.WHILE__LL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.WHILE__LL));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.WHILE__EE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.WHILE__EE));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.WHILE__CC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.WHILE__CC));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.WHILE__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.WHILE__Z));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.WHILE__K) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.WHILE__K));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.WHILE__LC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.WHILE__LC));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWhileAccess().getLlLCsParserRuleCall_1_0(), semanticObject.getLl());
		feeder.accept(grammarAccess.getWhileAccess().getEeEXPRParserRuleCall_2_0(), semanticObject.getEe());
		feeder.accept(grammarAccess.getWhileAccess().getCcLCsParserRuleCall_3_0(), semanticObject.getCc());
		feeder.accept(grammarAccess.getWhileAccess().getZLCsParserRuleCall_5_0(), semanticObject.getZ());
		feeder.accept(grammarAccess.getWhileAccess().getKCommandsParserRuleCall_6_0(), semanticObject.getK());
		feeder.accept(grammarAccess.getWhileAccess().getLcLCsParserRuleCall_7_0(), semanticObject.getLc());
		feeder.finish();
	}
}
