/*
 * generated by Xtext
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.langage_while.Assign;
import org.xtext.langage_while.Command;
import org.xtext.langage_while.Commands;
import org.xtext.langage_while.Definition;
import org.xtext.langage_while.Expr;
import org.xtext.langage_while.ExprAnd;
import org.xtext.langage_while.ExprEq;
import org.xtext.langage_while.ExprNot;
import org.xtext.langage_while.ExprOr;
import org.xtext.langage_while.ExprSimple;
import org.xtext.langage_while.Exprs;
import org.xtext.langage_while.For;
import org.xtext.langage_while.Foreach;
import org.xtext.langage_while.Function;
import org.xtext.langage_while.If;
import org.xtext.langage_while.Ifconfort;
import org.xtext.langage_while.Input;
import org.xtext.langage_while.LExpr;
import org.xtext.langage_while.Langage_whilePackage;
import org.xtext.langage_while.Model;
import org.xtext.langage_while.Output;
import org.xtext.langage_while.Program;
import org.xtext.langage_while.SYMB;
import org.xtext.langage_while.VAR;
import org.xtext.langage_while.Vars;
import org.xtext.langage_while.While;
import org.xtext.services.Langage_whileGrammarAccess;

@SuppressWarnings("all")
public class Langage_whileSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private Langage_whileGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == Langage_whilePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case Langage_whilePackage.ASSIGN:
				sequence_Assign(context, (Assign) semanticObject); 
				return; 
			case Langage_whilePackage.COMMAND:
				sequence_Command(context, (Command) semanticObject); 
				return; 
			case Langage_whilePackage.COMMANDS:
				sequence_Commands(context, (Commands) semanticObject); 
				return; 
			case Langage_whilePackage.DEFINITION:
				sequence_Definition(context, (Definition) semanticObject); 
				return; 
			case Langage_whilePackage.EXPR:
				sequence_Expr(context, (Expr) semanticObject); 
				return; 
			case Langage_whilePackage.EXPR_AND:
				sequence_ExprAnd(context, (ExprAnd) semanticObject); 
				return; 
			case Langage_whilePackage.EXPR_EQ:
				sequence_ExprEq(context, (ExprEq) semanticObject); 
				return; 
			case Langage_whilePackage.EXPR_NOT:
				sequence_ExprNot(context, (ExprNot) semanticObject); 
				return; 
			case Langage_whilePackage.EXPR_OR:
				sequence_ExprOr(context, (ExprOr) semanticObject); 
				return; 
			case Langage_whilePackage.EXPR_SIMPLE:
				sequence_ExprSimple(context, (ExprSimple) semanticObject); 
				return; 
			case Langage_whilePackage.EXPRS:
				sequence_Exprs(context, (Exprs) semanticObject); 
				return; 
			case Langage_whilePackage.FOR:
				sequence_For(context, (For) semanticObject); 
				return; 
			case Langage_whilePackage.FOREACH:
				sequence_Foreach(context, (Foreach) semanticObject); 
				return; 
			case Langage_whilePackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case Langage_whilePackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case Langage_whilePackage.IFCONFORT:
				sequence_Ifconfort(context, (Ifconfort) semanticObject); 
				return; 
			case Langage_whilePackage.INPUT:
				sequence_Input(context, (Input) semanticObject); 
				return; 
			case Langage_whilePackage.LEXPR:
				sequence_LExpr(context, (LExpr) semanticObject); 
				return; 
			case Langage_whilePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case Langage_whilePackage.OUTPUT:
				sequence_Output(context, (Output) semanticObject); 
				return; 
			case Langage_whilePackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case Langage_whilePackage.SYMB:
				sequence_SYMB(context, (SYMB) semanticObject); 
				return; 
			case Langage_whilePackage.VAR:
				sequence_VAR(context, (VAR) semanticObject); 
				return; 
			case Langage_whilePackage.VARS:
				sequence_Vars(context, (Vars) semanticObject); 
				return; 
			case Langage_whilePackage.WHILE:
				sequence_While(context, (While) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (vs=Vars ex=Exprs)
	 */
	protected void sequence_Assign(EObject context, Assign semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.ASSIGN__VS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.ASSIGN__VS));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.ASSIGN__EX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.ASSIGN__EX));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAssignAccess().getVsVarsParserRuleCall_0_0(), semanticObject.getVs());
		feeder.accept(grammarAccess.getAssignAccess().getExExprsParserRuleCall_4_0(), semanticObject.getEx());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         nop='nop' | 
	 *         assign=Assign | 
	 *         wh=While | 
	 *         for=For | 
	 *         if=If | 
	 *         fore=Foreach | 
	 *         ifc=Ifconfort
	 *     )
	 */
	protected void sequence_Command(EObject context, Command semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (c+=Command c+=Command*)
	 */
	protected void sequence_Commands(EObject context, Commands semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (in=Input com=Commands out=Output)
	 */
	protected void sequence_Definition(EObject context, Definition semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.DEFINITION__IN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.DEFINITION__IN));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.DEFINITION__COM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.DEFINITION__COM));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.DEFINITION__OUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.DEFINITION__OUT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDefinitionAccess().getInInputParserRuleCall_2_0(), semanticObject.getIn());
		feeder.accept(grammarAccess.getDefinitionAccess().getComCommandsParserRuleCall_5_0(), semanticObject.getCom());
		feeder.accept(grammarAccess.getDefinitionAccess().getOutOutputParserRuleCall_10_0(), semanticObject.getOut());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (exo1=ExprOr exo2+=ExprOr*)
	 */
	protected void sequence_ExprAnd(EObject context, ExprAnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((exS1=ExprSimple exS2=ExprSimple) | ex=Expr)
	 */
	protected void sequence_ExprEq(EObject context, ExprEq semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (exQ1=ExprEq | exQ2=ExprEq)
	 */
	protected void sequence_ExprNot(EObject context, ExprNot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (exn1=ExprNot exn2+=ExprNot*)
	 */
	protected void sequence_ExprOr(EObject context, ExprOr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         nil='nil' | 
	 *         v=VAR | 
	 *         sym=SYMB | 
	 *         ((mot='cons' | mot='list') lex=LExpr) | 
	 *         ((mot='hd' | mot='tl') ex=Expr) | 
	 *         (sym=SYMB lex=LExpr)
	 *     )
	 */
	protected void sequence_ExprSimple(EObject context, ExprSimple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (exs=ExprSimple | exa=ExprAnd)
	 */
	protected void sequence_Expr(EObject context, Expr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (ex+=Expr ex+=Expr*)
	 */
	protected void sequence_Exprs(EObject context, Exprs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (ex=Expr c=Commands)
	 */
	protected void sequence_For(EObject context, For semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOR__EX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOR__EX));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOR__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOR__C));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getForAccess().getExExprParserRuleCall_2_0(), semanticObject.getEx());
		feeder.accept(grammarAccess.getForAccess().getCCommandsParserRuleCall_6_0(), semanticObject.getC());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (ex1=Expr ex2=Expr c=Commands)
	 */
	protected void sequence_Foreach(EObject context, Foreach semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOREACH__EX1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOREACH__EX1));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOREACH__EX2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOREACH__EX2));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FOREACH__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FOREACH__C));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getForeachAccess().getEx1ExprParserRuleCall_2_0(), semanticObject.getEx1());
		feeder.accept(grammarAccess.getForeachAccess().getEx2ExprParserRuleCall_6_0(), semanticObject.getEx2());
		feeder.accept(grammarAccess.getForeachAccess().getCCommandsParserRuleCall_10_0(), semanticObject.getC());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=SYMB def=Definition)
	 */
	protected void sequence_Function(EObject context, Function semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FUNCTION__NAME));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.FUNCTION__DEF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.FUNCTION__DEF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFunctionAccess().getNameSYMBParserRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFunctionAccess().getDefDefinitionParserRuleCall_5_0(), semanticObject.getDef());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (ex=Expr ct=Commands ce=Commands)
	 */
	protected void sequence_If(EObject context, If semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.IF__EX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.IF__EX));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.IF__CT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.IF__CT));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.IF__CE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.IF__CE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIfAccess().getExExprParserRuleCall_2_0(), semanticObject.getEx());
		feeder.accept(grammarAccess.getIfAccess().getCtCommandsParserRuleCall_6_0(), semanticObject.getCt());
		feeder.accept(grammarAccess.getIfAccess().getCeCommandsParserRuleCall_10_0(), semanticObject.getCe());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (ex=Expr c=Commands)
	 */
	protected void sequence_Ifconfort(EObject context, Ifconfort semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.IFCONFORT__EX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.IFCONFORT__EX));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.IFCONFORT__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.IFCONFORT__C));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIfconfortAccess().getExExprParserRuleCall_2_0(), semanticObject.getEx());
		feeder.accept(grammarAccess.getIfconfortAccess().getCCommandsParserRuleCall_6_0(), semanticObject.getC());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (v+=VAR v+=VAR*)
	 */
	protected void sequence_Input(EObject context, Input semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     e+=Expr+
	 */
	protected void sequence_LExpr(EObject context, LExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     nn=Program
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.MODEL__NN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.MODEL__NN));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getModelAccess().getNnProgramParserRuleCall_0(), semanticObject.getNn());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (v+=VAR v+=VAR*)
	 */
	protected void sequence_Output(EObject context, Output semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (f+=Function* (u=CR pp=Program)?)
	 */
	protected void sequence_Program(EObject context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (bs=BASESYMB cf=CONF)
	 */
	protected void sequence_SYMB(EObject context, SYMB semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.SYMB__BS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.SYMB__BS));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.SYMB__CF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.SYMB__CF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSYMBAccess().getBsBASESYMBTerminalRuleCall_0_0(), semanticObject.getBs());
		feeder.accept(grammarAccess.getSYMBAccess().getCfCONFTerminalRuleCall_1_0(), semanticObject.getCf());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (bv=BASEVAR cf=CONF)
	 */
	protected void sequence_VAR(EObject context, VAR semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.VAR__BV) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.VAR__BV));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.VAR__CF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.VAR__CF));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getVARAccess().getBvBASEVARTerminalRuleCall_0_0(), semanticObject.getBv());
		feeder.accept(grammarAccess.getVARAccess().getCfCONFTerminalRuleCall_1_0(), semanticObject.getCf());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (vs+=VAR vs+=VAR*)
	 */
	protected void sequence_Vars(EObject context, Vars semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (ex=Expr c=Commands)
	 */
	protected void sequence_While(EObject context, While semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.WHILE__EX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.WHILE__EX));
			if(transientValues.isValueTransient(semanticObject, Langage_whilePackage.Literals.WHILE__C) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Langage_whilePackage.Literals.WHILE__C));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getWhileAccess().getExExprParserRuleCall_2_0(), semanticObject.getEx());
		feeder.accept(grammarAccess.getWhileAccess().getCCommandsParserRuleCall_6_0(), semanticObject.getC());
		feeder.finish();
	}
}
