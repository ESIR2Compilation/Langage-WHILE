/*
 * generated by Xtext
 */
package org.xtext.generator

import com.google.inject.Inject
import java.io.BufferedWriter
import java.io.File
import java.io.FileWriter
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.resource.XtextResourceSet
import org.xtext.Langage_whileStandaloneSetup
import org.xtext.langage_while.Command
import org.xtext.langage_while.Commands
import org.xtext.langage_while.EXPR
import org.xtext.langage_while.EXPRAND
import org.xtext.langage_while.EXPREQ
import org.xtext.langage_while.EXPRNOT
import org.xtext.langage_while.EXPROR
import org.xtext.langage_while.EXPRS
import org.xtext.langage_while.EXPRSIMPLE
import org.xtext.langage_while.Function
import org.xtext.langage_while.Input
import org.xtext.langage_while.LC
import org.xtext.langage_while.LCs
import org.xtext.langage_while.LEXPR
import org.xtext.langage_while.Model
import org.xtext.langage_while.Output
import org.xtext.langage_while.Vars
import org.xtext.langage_while.If
import org.xtext.langage_while.Assign
import org.xtext.langage_while.For
import org.xtext.langage_while.Foreach
import org.xtext.langage_while.While
import tabSymb.Fonction
import tabSymb.TabSymbole
import org.xtext.langage_while.Def
import Chevron.Chevron3a
import java.util.*

class Langage_whileGenerator implements IGenerator {
	
	
	def public File generate(String path, String file)
	{
		val injector = new Langage_whileStandaloneSetup().createInjectorAndDoEMFRegistration();
		val resourceSet = injector.getInstance(XtextResourceSet);
		val uri = URI.createURI(path + file);
		
		var pos = file.lastIndexOf(".");
		var ext = file.substring(pos+1);
		//TODO
		if (! ext.equals("while"))
			return null;
			
		val xtextResource = resourceSet.getResource(uri, true);
		EcoreUtil.resolveAll(xtextResource);
		var name = file.substring(0, pos);
		var out = name;
		if (path.equals("src/outputs/"))
			out += "1";
		out += ".whpp";
			
		try{
			
  			val fstream = new FileWriter("src/outputs/" + out);
  			val buff = new BufferedWriter(fstream);
  			for(p: xtextResource.allContents.toIterable.filter(Function))
				buff.write(p.compile().toString);
  				buff.close();
  			return new File("src/outputs/" + out);
  		}catch (Exception e){
  			e.printStackTrace();
  		}
  		return null;
	}
	
	def Fonction createFonct(int i){
		return  new Fonction("funct"+i);
	}
	def List<Chevron3a> createList(){
		return new ArrayList<Chevron3a>();
	}
	
	  @Inject extension IQualifiedNameProvider
	
		TabSymbole tableS= new TabSymbole();
		Fonction fonct;
		int cpt=0;
		List <Chevron3a> listChev; 
		Map<String,List <Chevron3a> > code3a;
	
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
   
   		var File file = new File(resource.URI.toString);
		var String name = file.name;
		
				if (name.contains("."))
			name = name.substring(0, name.lastIndexOf("."));
		
				var String output = "";
		
    for(e: resource.allContents.toIterable.filter(typeof(Function))) {
    				output += e.compile + '\n'
        }
      fsa.generateFile(name+".whpp",output)
    }
  
		
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(typeof(Greeting))
//				.map[name]
//				.join(', '))
	


	def compile (Function f)
	'''	«tableS.addSymbole(f.nom)»
	« cpt++»
	« fonct = createFonct(cpt) »
	«tableS.addFonction(f.nom,fonct)»
	« listChev = createList()»
	«code3a.put(f.nom,listChev)
	
	»
		
		function  «f.nom» :
		 « f.d.compile(f.nom) »

	'''
	
	def compile (Def d, String a)
	'''
				read «d.in.compile(a)+"
	"» % «d.v.compile+"
	"» % write  «d.o.compile(a)»
	'''
	
	def compile (Input l, String a)
	'''«fonct.incNbEntree()»
	«if (l.y!=null){
	fonct.addVariable(l.y)
	listChev.add(new Chevron3a("read",l.y,null,null))
	}
	else
	fonct.addVariable(l.v)»
	«(l.y)  ?: ((l.v)+" , "+(l.in.compile(a)))» 
	«listChev.add(new Chevron3a("read",l.v,null,null))»
		'''
	
	
	def compile (Commands n)
	'''

	«n.a.compile»
	«IF n.s != null»
	«n.s.compile»
	«ENDIF»
	''' 
	

	def compile (Output O, String a)
	'''
	«fonct.incNbSortie()»
	«if (O.s!=null){
	listChev.add(new Chevron3a("write",null,O.s,null))
	}
	}
	else
	
	(O.s) ?:  ((O.n)+", "+(O.o.compile(a)))»
	'''
	/* */
	def compile (Command c)  // a continuer
	'''
	«IF c.affect != null»«c.affect.compile»«ENDIF»
	«IF c.nop != null»nop«ENDIF»
	«IF c.iff != null»«c.iff.compile»«ENDIF»
	«IF c.wh != null»«c.wh.compile»«ENDIF»
	«IF c.forr != null»«c.forr.compile»«ENDIF»
	«IF c.fore != null»«c.fore.compile»«ENDIF»
	'''
	
	
	def compile(Assign a)
	 '''
	 «a.e» := «a.n»
	 '''
	def compile(If i) 
	'''
	if «i.jj»
	then
	«i.c2»
	else
	«i.o»
	fi
	'''

	def compile(For f)
	 '''
	 for «f.hh»
	 do
	 «f.c1»
	 od
	'''

	def compile(Foreach f) 
	'''
	foreach «f.wx» in «f.e1»
	do
	«f.c3»
	od
	'''

	def compile(While w) 
	'''
	while «w.ee»
	do
	«w.k»
	od
	'''
	
	def compile (Vars v)
	'''
	«(v.a) + ((", "+(v)) ?: (""))»
	'''
	
	def compile (EXPRS e)
	'''
	« e.f.compile + ( (", " + e.e2.compile) ?: ("") )
	»
	'''
	
	def compile (LEXPR l)
	'''
	«("/t"+(l.n.compile)) ?:(l)»
	'''	
	
	def compile (EXPR e)
	'''
	«IF e.e1 != null»«e.e1.compile»«ENDIF»
	«IF e.ex != null»«e.ex.compile»«ENDIF»

	'''
		
	def compile (EXPRSIMPLE e) // a revoir
	'''
	«IF e.nil != null»nil«ENDIF»
	«IF e.v != null»«e.v»«ENDIF»
	«IF e.sym != null && e.lex == null»«e.sym»«ENDIF»
	«IF e.mot != null && e.lex != null »(«e.mot» «e.lex.compile»)«ENDIF»
	«IF e.mot != null && e.ex != null »(«e.mot» «e.ex.compile»)«ENDIF»
	«IF e.sym != null && e.lex != null »(«e.sym» «e.lex.compile»)«ENDIF»
	
	«if (e.v.length != 0
	)
	tableS.addSymbole(e.v)»
		'''
		
		
	/*
	
		«"nil" 
	?:( (ex.l) 
		
		?: ((ex.s)
			 
			?: ( ( "( cons" + ex.yy.compile + ")" )
				
				?: ( ("( hd " + ex.g.compile + ")")
					
					?: ( ("( list " + ex.b.compile)
						
						?: ( ("( tl " + ex.g.compile + ")")
							
							?: ("(" + ex.v + ex.w.compile + ")"
											
							)
							
						)
						
					) 
					
				)
						
			)
			
		) 
		
	)»
	*/
	def compile (EXPRAND e)
	'''
	«(e.f.compile) + (( " and "  + e.compile) ?: (""))
	»
	'''
	
	def compile (EXPROR e)
	'''
	«(e.e1.compile) + (( " or " + e.compile) ?: (""))
	»
	'''
	def compile (EXPRNOT e)
	'''
	« (("not ") ?: ("")) + e.e1.compile
	»
	'''
	
	def compile (EXPREQ f)
	'''
	« (f.e1.compile +  " =? " + f.w.compile) ?: ("(" + f.ex.compile + ")")
	»
	'''
	
	
	def compile (LC m)
	'''
	« (m.a)
	?:( (m.z) 
		?:( (m.e)
			?: (m.r)
			
		)
		
	)
	»
	'''

	
	
}

